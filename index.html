<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>JsTOTPAuthenticator</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="manifest" href="./manifest.json"> 
  
  <link rel='stylesheet' href='https://cdn.simplecss.org/simple.css'>
  
<style>
#theBar {
  _border: solid;
  _border-width: 1pt;
  height: 1pt;
  background-color: red;
}

.border {
  border: solid;
  border-width: 1pt;
}
</style>

  
  
  
</head>

<body>
  <div_header style="display:flex;">
  <center style="width:100%">
    <span id="menu_icon">
      <a onclick="openMenu()" class="button">&#x2261;</a>
    </span>
    <span id="x_icon" hidden>
      <a onclick="closeMenu()" class="button">X</a>
    </span>
    &nbsp;&nbsp;&nbsp;
    <span>
      JsTOTPAuthenticator
    </span>
    <hr>
  </center>
</div_header>

<br>&nbsp;

<div_main_page id="main_page_component">

  <label for="seed">Seed</label><input type="text" id="seed" name="seed" placeholder="Seed in Base32" oninput="eachSecond();">

  <div>
    <span>Step Hexed: </span>
    <span id="step"></span>
  </div>
  <div>
    <span>Seed Hexed: </span>
    <span id="key"></span>
  </div>
  <div>
    <span>TOTP:</span>
    <span id="totp"></span>
  </div>
  <div class="border">
    <div id="theBar"></div>
  </div>
  <div>
    <span>Countdown: </span>
    <span id="countdown"></span>
  </div>
  <div>
  <div id="error"></div>
  </div>
  <div>
  <div id="db"></div>
  </div>
    <div>
  <div id="masterKey"></div>
  </div>
  
  
</div_main_page>

<div_menu_page id="menu_page_component" hidden>

  <form>
    <center>
      <div>
        <input type="button" value="Get Alias List" onclick="GetAliasList();">
      </div>

      <div>
        <input type="button" value="Save Alias List" onclick="if(confirm('This will change your list. Are you sure?')){SaveAliasList();}">
      </div>

      <div>
        <input type="button" value="Export Alias List to Clipboard" onclick="if(confirm('This will export all Alias, settings, and comments to clipboard. Are you sure?')){ ExportAll(); }">
      </div>

      <div>
        <textarea id="JSONSave" rows="3" cols="50" placeholder="Import/Export/Backup Alias List. Save the text generated in a safe location." title="You can import/export your current Alias list (which is saved in the local cookie). This is helful to move it to another computer or use it as a backup." class="u-full-width">
</textarea>
      </div>
    </center>
  </form>

  <center>
    <div>
      <a href="#" id="install" class="button">Install as PWA</a>
    </div>

    <div>
      Links below will open in your default browser.
    </div>

    <div>
      <a href="https://vpelss.github.io/Forever_Passwords//README.md" class="button u-full-width" target="_blank">Help/Read Me</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator" target="_blank" class="button u-full-width">Github</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator/blob/main/LICENSE" target="_blank" class="button">Licence</a>
    </div>

    <div>
      <a href="https://www.emogic.com/cgi/fp/backup.php" target="blank" class="button u-full-width">Doesn't work?</a>
    </div>

  </center>

</div_menu_page>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js'></script>
    <script id="rendered-js" >
// the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time
"use strict";
let localStorageName = "JsTOTPAuthenticator";
let GlobalAssociativeArray = {};
let plaintext;

const TE = new TextEncoder();
let TD = new TextDecoder();

function openMenu() {
  document.getElementById("main_page_component").style.display = "none";
  document.getElementById("menu_page_component").style.display = "block";
  document.getElementById("menu_icon").style.display = "none";
  document.getElementById("x_icon").style.display = "inline";
}

function closeMenu() {
  document.getElementById("main_page_component").style.display = "block";
  document.getElementById("menu_page_component").style.display = "none";
  document.getElementById("menu_icon").style.display = "inline";
  document.getElementById("x_icon").style.display = "none";
}

function GetAliasList() {
  LocalStorageToVar();
  document.getElementById("JSONSave").value = JSON.stringify(
    GlobalAssociativeArray,
    null,
    "\t"
  );
}

function VarToLocalStorage() {
  let AliasListString = JSON.stringify(GlobalAssociativeArray);
  if (supports_html5_storage()) {
    localStorage[localStorageName] = AliasListString;
    //setCookie("AliasList", "", yesterday, "", "", ""); //erase cookie as we want to use local storage now.
  } else {
    //save to cookie
    setCookie("AliasList", AliasListString, localStorageName, "", "", "");
  }
}

function LocalStorageToVar() {
  if (supports_html5_storage()) {
    if (typeof localStorage[localStorageName] === "undefined") {
      return;
    } //nothing to restore
    GlobalAssociativeArray = JSON.parse(localStorage[localStorageName]);
  } else {
    let data = getCookie("AliasList") || "{}";
    GlobalAssociativeArray = JSON.parse(data);
  }
}

function SaveAliasList() {
  if (document.getElementById("JSONSave").value == "") {
    GlobalAssociativeArray = {};
  } else {
    GlobalAssociativeArray = JSON.parse(
      document.getElementById("JSONSave").value
    );
  }
  VarToLocalStorage();
  //BuildAliasSelect();
}

function supports_html5_storage() {
  try {
    return "localStorage" in window && window.localStorage !== null;
    //return false;
  } catch (e) {
    return false;
  }
}

function ExportAll() {
  LocalStorageToVar();
  copytoclipboard2(JSON.stringify(GlobalAssociativeArray));
  alert("All your Alias, settings, and comments are on the clipboard!");
}

function copytoclipboard2(text) {
  let textarea = document.createElement("TEXTAREA");
  document.body.appendChild(textarea);
  textarea.innerHTML = text;
  textarea.value = text;
  textarea.select();
  document.execCommand("copy", false, null);
  textarea.remove();
}

// for references see: https://github.com/vpelss/JsTOTPAuthenticator
async function hmac(
  keyHexString,
  stepHexString16Bytes,
  returnDigits,
  hashFunctionString
) {
  let totp;
  try {
    let blockSize = 64;
    let k, msg, tempUint8Array, hashed;

    //all our input key strings should only have hex characters [0 .. F]
    msg = Uint8Array.fromHex(stepHexString16Bytes);
    k = Uint8Array.fromHex(keyHexString); //only accepts hex string lengths of even values and convertys to bytes. byte = 2 x hex

    /*
    //HMAC: instructive
    //hmac_sha https://en.wikipedia.org/wiki/HMAC

    // create our Uint8Array key to the blockSize sized
    if (k.length > blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
      tempUint8Array.set(new Uint8Array(hashed));
      k = tempUint8Array;
    } // Keys longer than blockSize are shortened by hashing them
    // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
    if (k.length < blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      tempUint8Array.set(k);
      k = tempUint8Array;
    }
    // k should now be blockSize

    // create ipad and opad https://datatracker.ietf.org/doc/html/rfc2104#section-2
    let okey = new Uint8Array(k);
    okey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x5c;
    }); //key xor 0x5c
    let ikey = new Uint8Array(k);
    ikey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x36;
    }); //key xor 0x36

    // now do hash(o_key_pad concatenate hash(i_key_pad concatenate msg))

    tempUint8Array = concatenateUint8arrays([ikey, msg]); // i_key_pad + msg
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    tempUint8Array = new Uint8Array(hashed); // hash(i_key_pad concatenate msg)

    tempUint8Array = concatenateUint8arrays([okey, tempUint8Array]); //o_key_pad âˆ¥ hash(i_key_pad + msg)
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    hashed = new Uint8Array(hashed); // hash(o_key_pad concatenate hash(i_key_pad concatenate msg))
   */

    //HMAC: simpler, but not instructive
    //let hashed2 = await window.crypto.subtle.sign("HMAC",key,encoded);
    let cryptoKey = await window.crypto.subtle.importKey(
      "raw",
      k,
      { name: "HMAC", hash: { name: "SHA-1" } },
      1,
      ["sign", "verify"]
    );
    hashed = await window.crypto.subtle.sign("HMAC", cryptoKey, msg);
    hashed = new Uint8Array(hashed);

    //https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
    let offset = hashed[hashed.length - 1] & 0xf; //last 4 bits of hashed

    //take 4 bytes at offset (minus the first bit) and use bits to create a decimal #
    let myBinary =
      ((hashed[offset] & 0x7f) << 24) | // not signed
      (hashed[offset + 1] << 16) |
      (hashed[offset + 2] << 8) |
      hashed[offset + 3];

    //take deciamal output of myBinary and reduce to returnDigits decimal characters
    // opt is the same as taking dp/myBinary taking the decimal and multiplying with dp
    let dp = 10 ** returnDigits;
    let otp = myBinary % dp;

    totp = otp.toString();
    while (totp.length < returnDigits) {
      // make sure it is returnDigits long. pad to the left
      totp = "0" + totp;
    }
    document.getElementById("error").innerHTML = ""; //clear error on success
    document.getElementById("step").innerHTML = stepHexString16Bytes;
    document.getElementById("key").innerHTML = keyHexString;
    document.getElementById("totp").innerHTML = totp;
  } catch (error) {
    document.getElementById("error").innerHTML =
      document.getElementById("error").innerHTML + error;
    document.getElementById("totp").innerHTML = "";
  }
}

//not required
function encodeBase32(data) {
  const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let binaryString = "";
  for (let i = 0; i < data.length; i++) {
    binaryString += data.charCodeAt(i).toString(2).padStart(8, "0");
  }
  let padding = binaryString.length % 5;
  if (padding !== 0)
    binaryString = binaryString.padEnd(binaryString.length + 5 - padding, "0");
  let encoded = "";
  for (let i = 0; i < binaryString.length; i += 5) {
    encoded += BASE32_ALPHABET[parseInt(binaryString.slice(i, i + 5), 2)];
  }
  while (encoded.length % 8 !== 0) encoded += "=";
  return encoded;
}

// modified https://medium.com/@at.kishor.k/demystifying-base32-an-in-depth-guide-to-this-encoding-standard-697b9426fc25
function decodeBase32toHex(data) {
  const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  const HEX_ALPHABET = "0123456789ABCDEF";
  data = data.replace(/=/g, ""); //remove padding
  let binaryString = "";
  for (let i = 0; i < data.length; i++) {
    binaryString += BASE32_ALPHABET.indexOf(data[i])
      .toString(2)
      .padStart(5, "0");
  }
  //CHANGE to 4 for hex character output
  //let padding = binaryString.length % 8;
  let padding = binaryString.length % 4;
  if (padding !== 0) {
    binaryString = binaryString.slice(0, -padding);
  }
  let decoded = "";
  for (let i = 0; i < binaryString.length; i += 4) {
    let decimalEquivilant = parseInt(binaryString.slice(i, i + 4), 2);
    decoded += HEX_ALPHABET[decimalEquivilant];
    //decoded += parseInt(binaryString.slice(i, i + 4), 2).toString(16).toUpperCase();
  }
  return decoded;
}

// https://evanhahn.com/the-best-way-to-concatenate-uint8arrays/
function concatenateUint8arrays(uint8arrays) {
  // Determine the length of the result.
  const totalLength = uint8arrays.reduce(
    (total, uint8array) => total + uint8array.byteLength,
    0
  );
  // Allocate the result.
  const result = new Uint8Array(totalLength);
  // Copy each Uint8Array into the result.
  let offset = 0;
  uint8arrays.forEach((uint8array) => {
    result.set(uint8array, offset);
    offset += uint8array.byteLength;
  });
  return result;
}

//DELETED
function _HexStringtoString(hexString) {
  let myUint8Array = Uint8Array.fromHex(hexString);
  let myString = TD.decode(myUint8Array);
  return myString;
}

//DELETE
function _stringToBytesArray(val) {
  const result = [];
  for (let i = 0; i < val.length; i++) {
    result.push(val.charCodeAt(i));
  }
  result = new Uint8Array(result);
  return result;
}

//DELETE
// Convert a hex string to Uint8Array
function _hexToByteArray(hex) {
  let bytes = [];
  for (let c = 0; c < hex.length; c += 2)
    bytes.push(parseInt(hex.substr(c, 2), 16));
  //modified to return Uint8Array
  bytes = new Uint8Array(bytes);
  return bytes;
}

//DELETE
// Convert a byte array to a hex string
function bytesToHex(bytes) {
  let hex = [];
  for (let i = 0; i < bytes.length; i++) {
    let current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];
    hex.push((current >>> 4).toString(16));
    hex.push((current & 0xf).toString(16));
  }
  return hex.join("");
}

async function eachSecond() {
  let unixTime = Date.now() / 1000; //in seconds
  let stepNow = unixTime / 30;
  let stepInt = Math.floor(stepNow);
  let timeLeft = Math.floor(30 - 30 * (stepNow - stepInt));
  //step MUST be in string HEX
  let step = stepInt.toString(16);
  //show countdown
  var elem = document.getElementById("theBar");
  let barWidth = Math.floor((100 * timeLeft) / 30);
  elem.style.width = barWidth + "%";
  document.getElementById("countdown").innerHTML = timeLeft;
  do {
    step = "0" + step;
  } while (step.length < 16);
  // step needs to be 16 characters
  let seedBase32 = document.getElementById("seed").value;

  //since base32 each character is 5 bits, we need 8 base32 characters to encode 5 byte characters
  //so padding IS REQUIRED if base32 is not a multiple of 40 bits
  // google 16, 24, 32 base32 char only. so 80, 120, 160 bits : 10, 15, 20 bytes
  try {
    if (seedBase32.length % 8 != 0)
      // test modulo 8
      throw "The seed length must be a multiple of 8 characters and be composed of base32 characters [ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]";
  } catch (error) {
    document.getElementById("error").innerHTML = error + "<br>";
    document.getElementById("totp").innerHTML = "";
    return;
  }
  let seed = decodeBase32toHex(seedBase32.toUpperCase()); //base32Str to HexStr

  let returnDigits = 6;
  let crypto = "sha1";

  try {
    hmac(seed, step, returnDigits, crypto);
  } catch (error) {
    document.getElementById("error").innerHTML =
      document.getElementById("error").innerHTML + error;
    document.getElementById("totp").innerHTML = "";
  }

  document.getElementById("db").innerHTML = plaintext;
}

// MAIN //

//test value
document.getElementById("seed").value = "CCCCCCCC";
//start counter
let myInterval = setInterval(eachSecond, 1000);
//load database
LocalStorageToVar();

//unencrypt AES CGM

// https://stackoverflow.com/questions/68031025/decrypt-aes-in-javascript
// https://dev.to/shubhamkhan/beginners-guide-to-aes-encryption-and-decryption-in-javascript-using-cryptojs-592
//https://en.wikipedia.org/wiki/Initialization_vector
//https://www.reddit.com/r/learnjavascript/comments/1254hjd/cryptography_given_i_have_a_key_how_can_i_use/

// https://github.com/beemdevelopment/Aegis/blob/master/app/src/main/java/com/beemdevelopment/aegis/crypto/bc/SCrypt.java
//https://github.com/tonyg/js-scrypt
//https://github.com/ricmoo/scrypt-js?utm_source=cdnjs&utm_medium=cdnjs_link&utm_campaign=cdnjs_library#readme
//https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js

if (typeof GlobalAssociativeArray != "undefined") {
  // based on https://github.com/Sammy-T/avdu/blob/master/vault/decrypt.go
  // FindMasterKey uses the password to decrypt the master key
  // from the vault and returns the master key's bytes.

  // go salt, err := hex.DecodeString(slot.Salt)
  let saltString = GlobalAssociativeArray.header.slots[0].salt;
  let salt = Uint8Array.fromHex(saltString);

  // Create a key using the slot values and provided password
  // go key, err = scrypt.Key([]byte(pwd), salt, slot.N, slot.R, slot.P, 32)
  let n = GlobalAssociativeArray.header.slots[0].n;
  let r = GlobalAssociativeArray.header.slots[0].r;
  let p = GlobalAssociativeArray.header.slots[0].p;
  let dkLen = 32; //????
  let password = "Sickow13";
  password = password.normalize("NFKC");
  let pw = TE.encode(password);
let openKey ;
  
  //from https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js
  //https://github.com/ricmoo/scrypt-js?utm_source=cdnjs&utm_medium=cdnjs_link&utm_campaign=cdnjs_library#readme
  //password based key derivation
  let keyScrypt = scrypt.syncScrypt(pw, salt, n, r, p, dkLen);
  //scryptOutput =  await scrypt.scrypt( pw2 , salt , n , r , p  , dkLen);

  // go	block, err := aes.NewCipher(key)
  // NewCipher creates and returns a new cipher.Block. The key argument must be the AES key, either 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.

  // go aesgcm, err := cipher.NewGCM(block)

  //go nonce, err := hex.DecodeString(slot.KeyParams.Nonce)
  let nonceString = GlobalAssociativeArray.header.slots[0].key_params.nonce;
  //let nonceString = GlobalAssociativeArray.header.params.nonce;
  nonceString = nonceString.normalize("NFKC");
  let nonce = Uint8Array.fromHex(nonceString);

  // go	tag, err := hex.DecodeString(slot.KeyParams.Tag)
  let tagString = GlobalAssociativeArray.header.slots[0].key_params.tag;
  //let tagString = GlobalAssociativeArray.header.params.tag;
  let tag = Uint8Array.fromHex(tagString);
 
  //go slotKey, err := hex.DecodeString(slot.Key)
  let slotKeyString = GlobalAssociativeArray.header.slots[0].key;
  let slotKey = Uint8Array.fromHex(slotKeyString);
  
  // go var keyData []byte = append(slotKey, tag...)
  let keyDataString = slotKeyString + tagString;
  let keyData = Uint8Array.fromHex(keyDataString);
  //let keyData = concatenateUint8arrays([slotKey, tag]);

  // Attempt to decrypt the master key
  //go masterKey, err = aesgcm.Open(nil, nonce, keyData, nil)
async function decryptKey(){
 
 await window.crypto.subtle
    .importKey("raw", keyScrypt, { name: "AES-GCM" }, 1, ["encrypt", "decrypt"])
    .then(function (convertedKey) {
      //iv 12 bytes nonce, myKey 32 byte , keyData is ???
      let dc = decrypt(nonce, convertedKey, keyData);
      let t = 8;
    });
  
}
  
  decryptKey();

  async function decrypt(iv, key, ciphertext) {
    let decrypted;
    try {
      decrypted = await window.crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv
        },
        key,
        ciphertext
      );
    } catch (error) {
      document.getElementById("error").innerHTML =
        document.getElementById("error").innerHTML + error + DOMException.code;
    }
    let plaintext = decrypted;
    openKey = TD.decode(decrypted);
    return decrypted;
  }

  //let db = GlobalAssociativeArray.db;
  //dbByteArray = Uint8Array.fromBase64(db, { lastChunkHandling: "strict" });

  let h = 9;
}
  </script>

  
</body>

</html>
