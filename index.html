<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>AuthenticatorAnywhere</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="manifest" href="./manifest.json"> 
  
  <link rel='stylesheet' href='https://cdn.simplecss.org/simple.css'>
  
<style>
body {
  margin: 2px;
  width: 90%;
}

#header {
  position: sticky;
  top: 0;
  background-color: white;
  width: 100%;
}

.codeClass {
  font-size: 2rem;
}

.codeClassNext {
  font-size: 1rem;
  color: gray;
}

#theBarContainer{
background-color: lightgray; 
}

#theBar {
  height: 5px;
  background-color: red;
  width: 100%;
  transition : width 1s linear;
}

.myTemplate {
  display: table;
  width: 100%;
  border: solid;
  border-width: 1px;
  margin: 5px;
  padding: 5px;
}

.leftTemplate {
  display: table-cell;
}

.rightTemplate {
  display: table-cell;
  text-align: right;
}

#error {
  white-space: pre-wrap;
  display: block;
}

.secret {
  /*fix / block password managers forcing fields to fill*/
  -webkit-text-security: disc;
}

.secret:active {
  /*fix / block password managers forcing fields to fill*/
  -webkit-text-security: none;
}

/*
div,span {
  border: solid;
  border-width: 1px;
}
*/
</style>

  
  
  
</head>

<body>
  <div id="header">
  <center>
    <span id="menu_icon">
      <a onclick="openMenu();" class="button">&#x2261;</a>
    </span>
    <span id="x_icon" hidden>
      <a onclick="closeMenu()" class="button">X</a>
    </span>
    &nbsp;&nbsp;&nbsp;
    <span>
      AuthenticatorAnywhere
    </span>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span id="add_icon">
      <a onclick="openDialog('addEntryDialog')" class="button">+</a>
    </span>
  </center>
  <div>
    <div id="theBarContainer">
      <div id=theBar></div>
    </div>
  </div>
</div>

<div_main_page id="main_page_component">
  <div id="entriesDiv">
    <center><b>Waiting to load encrypted Aegis database...</b></center>
  </div>
</div_main_page>

<div_menu_page id="menu_page_component" hidden>

  <form>
    <center>
      <div>Import / Export encrypted JSON database</div>
      <div>
        <input type="button" value="Import encrypted JSON database text" onclick="if(confirm('This will overwrite your current Aegis JSON encrypted database. Are you sure?')){setLocalStorageFromTextbox();}">
      </div>
      <div>
        <input type="button" value="Export encrypted JSON database text" onclick="getLocalStorageToTextbox();">
      </div>
      <div>
        <input type="button" value="Export encrypted JSON database text to Clipboard" onclick="exportAll();">
      </div>
      <div>
        <textarea id="JSONSave" rows="3" cols="50" placeholder="Encrypted JSON database text goes here. Save this text in a safe location. Use it as a backup or to import it on another device." title="You can import/export your current  encrypted JSON database. This is helful to move it to another computer or to create  it as a backup." class="u-full-width">
</textarea>
      </div>
    </center>
  </form>

  <center>
    <div>
      <a href="#" id="changePassword" class="button" onclick="openDialog('changePasswordDialog')">Change Password</a>
    </div>

    <div>
      <a href="#" id="install" class="button">Install as PWA</a>
    </div>

    <div>
      Links below will open in your default browser.
    </div>

    <div>
      <a href="https://github.com/vpelss/AuthenticatorAnywhere/blob/main/README.md" class="button u-full-width" target="_blank">Help/Read Me</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator" target="_blank" class="button u-full-width">Github</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator/blob/main/LICENSE" target="_blank" class="button">Licence</a>
    </div>

  </center>

</div_menu_page>

<template id="theTemplate">
  <div id="${entryId}" class="myTemplate">
    <div class="leftTemplate">

      <div style="display: flex;">
        <span id="entryIssuer${entryId}">Issuer</span>
        :
        <span id="entryName${entryId}">Name</span>
      </div>

      <div>
        <span id="entryCode${entryId}" class="codeClass" onclick="copyElementInnerHTMLToClipboard('entryCode${entryId}')">Code</span>
        <span id="entryCodeNext${entryId}" class="codeClassNext" onclick="copyElementInnerHTMLToClipboard('entryCodeNext${entryId}')">CodeNext</span>
      </div>

    </div>

    <div class="rightTemplate">
      <a id="copyIcon${entryId}" href="#" class="button" onclick="copyElementInnerHTMLToClipboard('entryCode${entryId}')">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff">
          <path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z" />
        </svg>
      </a>
      <div id="editIcon${entryId}"><a href="#" class="button" onclick="editEntryDialog('${entryId}');">&#x2261;</a>
      </div>
    </div>
  </div>
</template>

<dialog id="passwordDialog">
  <p>Enter or Set a password for the Database</p>
  <form method="dialog" onsubmit="tryPassword(document.querySelector('#password').value);document.querySelector('#password').value='';">
    <center>
      <div>
        <input type="text" id="password" placeholder="Password" class="secret" autocomplete="off">
      </div>
      <div>
        <input type="submit" value="Submit">
      </div>
      <div>
        Or if you forgot your pw:
      </div>
      <div>
        <input type="button" value="Erase Database" onclick="wipeDatabase()">
      </div>
    </center>
  </form>
</dialog>

<dialog id="changePasswordDialog">
  <p>Add An Entry</p>
  <form method="dialog" onsubmit="changePassword(this)">
    <center>
      <div></div>
      <div>
        <input type="text" id="newPassword1" placeholder="New Password" autocomplete="off" class="secret">
      </div>
      <div>
        <input type="text" id="newPassword2" placeholder="New Password again" autocomplete="off" class="secret">
      </div>
      <div>
        <input type="submit" value="Submit">
      </div>
      <p></p>
      <div>
        <input type="button" value="Cancel" onclick="closeDialog('changePasswordDialog')">
      </div>
    </center>
  </form>
</dialog>

<dialog id="addEntryDialog">
  <p>Add An Entry</p>
  <form method="dialog" onsubmit="addEntry(this)">
    <center>
      <div>
        <input type="text" id="addEntryURL" placeholder="url otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&issuer=Example" autocomplete="off">
      </div>
      <div>OR</div>
      <div>
        <input type="text" id="addEntryIssuer" placeholder="Issuer / Company" autocomplete="off">
      </div>
      <div>
        <input type="text" id="addEntryName" placeholder="Name / Description" autocomplete="off">
      </div>
      <div>
        <input type="text" id="addEntrySecret" placeholder="Secret / Code" autocomplete="off">
      </div>
      <div>
        <input type="text" id="addEntryNote" placeholder="Note" autocomplete="off">
      </div>
      <div>
        <input type="submit" value="Submit">
      </div>
      <p></p>
      <div>
        <input type="button" value="Cancel" onclick="closeDialog('addEntryDialog')">
      </div>
    </center>
  </form>
</dialog>

<template id="editEntryTemplate">
  <div>
    <p>Edit Entry</p>
    <form method="dialog" onsubmit="editEntry('${entryId}')">
      <center>
        <div>
          <label for="editEntryIssuer">Issuer</label>
          <input type="text" id="editEntryIssuer" placeholder="Issuer" autocomplete="off" value="${entryIssuer}">
        </div>
        <div>
          <label for="editEntryName">Name</label>
          <input type="text" id="editEntryName" placeholder="Name" autocomplete="off" value="${entryName}">
        </div>
        <div>
          <label for="editEntryInfoSecret">Secret</label>
          <input type="text" id="editEntryInfoSecret" placeholder="Secret" autocomplete="off" class="secret" value="${entryInfoSecret}">
        </div>
        <div>
          <label for="editEntryNote">Note</label>
          <input type="text" id="editEntryNote" placeholder="Note" autocomplete="off" value="${entryNote}">
        </div>
        <div>
          <input type="submit" value="Submit">
        </div>
        <p></p>
        <div>
          <input type="button" value="Cancel" onclick="closeDialog('tempDialog')">
        </div>
        <p></p>
        <div>
          <input type="button" value="Delete Entry" onclick="deleteEntry('${entryId}')">
        </div>
      </center>
    </form>
  </div>
</template>

<dialog id="tempDialog">
  tempate id=editEntryTemplate will go here
</dialog>

<dialog id="copiedDialog">
  Code Copied to Clipboard
</dialog>

<dialog id="waitDialog">
  <center>
    <p>Please Wait</p>
    <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000">
      <path d="M324-111.5Q251-143 197-197t-85.5-127Q80-397 80-480t31.5-156Q143-709 197-763t127-85.5Q397-880 480-880t156 31.5Q709-817 763-763t85.5 127Q880-563 880-480t-31.5 156Q817-251 763-197t-127 85.5Q563-80 480-80t-156-31.5ZM480-160q64 0 123-24t104-69L480-480v-320q-134 0-227 93t-93 227q0 134 93 227t227 93Z" />
    </svg>
  </center>
</dialog>

<p></p>

<div id="error"></div>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js'></script>
    <script id="rendered-js" >
// scrypt from https://www.jsdelivr.com/package/npm/scrypt-js
// https://github.com/ricmoo/scrypt-js/

"use strict";

let password = ""; //it can be "", but harangue to set a password
let myInterval;
let localStorageName = "JsTOTPAuthenticator";
let localStorageObject = {};
let dbGlobal = {}; //entries, groups, ect
let errorArray = [];
let oldStepInt = 0;
let entriesDiv = document.querySelector("#entriesDiv");
const TE = new TextEncoder();
const TD = new TextDecoder();

// the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

//TO DO:
//generate or read qr code?
//scan qr code
//copy qr code
//create url
//create qr code
//backup reminder
//ADD web app code
//browser support alert?
//scrypt local?

// START MAIN LOOP //

main();

async function main() {
  try {
    //fresh start
    //closeDialog("waitDialog");
    openDialog("waitDialog");
    clearInterval(myInterval);
    closeMenu();
    errorArray = [];
    document.querySelector("#error").innerHTML = "";
    document.getElementById("JSONSave").value = "";
    entriesDiv.innerHTML =
      "<center><b>Loading database and decrypting...</b></center>"; //this may be an imp0rt (dont fix this) situation

    //does browser support local storage? yes continue : no stop
    if (!supportsHtml5Storage()) {
      closeDialog("waitDialog");
      throw {
        name: "Error",
        message: "HTML5 Storage is not supported in this browser"
      };
    }
    //is there  local storage and is it JSON? yes continue : no stop
    localStorageObject = getLocalStorage(); //load database
    //test to see if json is valid Aegis format. I am only weak testing for localStorageObject.db
    if (!isValidlocalStorageObject()) {
      entriesDiv.innerHTML =
        "<center><b>No database found. Import an encrypted JSON database with &#x2261; or start adding entries with the +</b></center>";
      closeDialog("waitDialog");
      return;
    }

    //assume pw is "" and try to decrypt
    //if it fails bring up passwordDialog it will either:
    //1. wipe local storage and run main()
    //2. set password and run main()
    //unencrypt Aegis JSON DB : AES CGM
    let dbJSON = await decryptDb(password);
    if (dbJSON == "") {
      closeDialog("waitDialog");
      //pw failed so open passwordDialog
      openDialog("passwordDialog");
      //throw {name: "main",message: "Password is incorrect or maybe JSON Database is corrupt"};
      return;
    }

    dbGlobal = JSON.parse(dbJSON);
    dbGlobal.entries = dbGlobal.entries;
    //let test = await encryptDb(password);

    // dbGlobal.entries = localStorageObject.entries;
    dbJSON = ""; //data no longer needed
    buildEntriesDOM(); //this has to be here as we need to wait for the promise

    //harangue those with a blank password
    if (password == "") {
      if (
        confirm(
          "You currently have a blank password. This means anyone can access your Authentication codes. This is unwise. Do you wish to set a password"
        )
      ) {
        openDialog("changePasswordDialog");
      }
    }

    closeDialog("waitDialog");
    myInterval = setInterval(eachSecond, 1000); //start counter
  } catch (err) {
    postError(err);
  }
}

async function eachSecond() {
  try {
    if (dbGlobal.entries.length == 0) {
      return "No entries yet";
    }
    let unixTime = Date.now() / 1000; //in seconds
    let stepNow = unixTime / 30;
    let stepInt = Math.floor(stepNow); //this changes when == to stepNow. so bar should be at 100%
    let step = stepInt.toString(16); //step MUST be in string HEX
    //show countdown
    // let percentDone = Math.floor( 100 * (stepNow - stepInt + (1/30)) ) ; //need to add one tick 1/30 to progress bar so we can reach 100%
    let percentDone = Math.floor(100 * (stepNow - stepInt));
    let barWidth = 100 - percentDone;
    if (stepInt != oldStepInt) {
      //percentDone will never coincide with our setInterval. so make barr 100 on change
      barWidth = 100;
      oldStepInt = stepInt;
    }

    let bar = document.querySelector("#theBar");
    bar.style.width = "" + barWidth + "%";

    // step needs to be 16 characters
    step = leaingZeros(step);

    //calc next one too
    let stepInt2 = stepInt + 1;
    let step2 = stepInt2.toString(16); //step MUST be in string HEX
    // step needs to be 16 characters
    step2 = leaingZeros(step2);

    // calculate and output code for each entry and place on template
    let entriesCount = 0;
    for (let entry of dbGlobal.entries) {
      let name = entry.name;
      let issuer = entry.issuer;

      let algo = entry.info.algo;
      let digits = entry.info.digits;
      let period = entry.info.period;
      let seedBase32 = entry.info.secret;
      let seed = decodeBase32toHex(seedBase32.toUpperCase()); //base32Str to HexStr

      let totp = await hmac(seed, step, digits, algo);
      let totp2 = await hmac(seed, step2, digits, algo);

      //document.getElementById("" + entriesCount).value = totp; //we are setting a value in a div. that can't be good
      document.getElementById("entryName" + entriesCount).innerHTML = name;
      document.getElementById("entryIssuer" + entriesCount).innerHTML = issuer;
      document.getElementById("entryCode" + entriesCount).innerHTML = totp;
      document.getElementById("entryCodeNext" + entriesCount).innerHTML = totp2;
      entriesCount += 1;
    }
  } catch (err) {
    postError(err);
  }
}

// BUTTON FUNCTIONS //

function copyElementInnerHTMLToClipboard(id) {
  try {
    let code = document.getElementById(id).innerHTML; //we stored a value in a div for simplicity
    copytoclipboard2(code);
    openDialog("copiedDialog");
    setTimeout(function () {
      closeDialog("copiedDialog");
    }, 1500);
  } catch (err) {
    postError(err);
  }
}

function editEntryDialog(id) {
  try {
    //build html tempalte with data
    let modifiedTemplate = template("editEntryTemplate", {
      entryId: "" + id,
      entryIssuer: dbGlobal.entries[id].issuer,
      entryName: dbGlobal.entries[id].name,
      entryNote: dbGlobal.entries[id].note,
      entryInfoSecret: dbGlobal.entries[id].info["secret"]
    });
    let el = document.querySelector("#tempDialog");
    el.innerHTML = modifiedTemplate;
    //open tempDialog: it is temparary so our code knows all the ids and we can easily fill in all the input values
    openDialog("tempDialog");
  } catch (err) {
    postError(err);
  }
}

async function editEntry(id) {
  try {
    // tempDialog will contain the form
    let el = document.querySelector("#tempDialog").querySelector("form");
    let entryName = el.editEntryName.value;
    let entryIssuer = el.editEntryIssuer.value;
    let entryNote = el.editEntryNote.value;
    let entrySecret = el.editEntryInfoSecret.value;

    dbGlobal.entries[id].name = entryName;
    dbGlobal.entries[id].issuer = entryIssuer;
    dbGlobal.entries[id].note = entryNote;
    dbGlobal.entries[id].info.secret = entrySecret;

    await encryptDb(password);
    setLocalStorage(localStorageObject);
    main();
  } catch (err) {
    postError(err);
  }
}

async function deleteEntry(id) {
  try {
    //are you sure?
    if (confirm("This will delete this Entry. Are you sure?")) {
      dbGlobal.entries.splice(id, 1);
      await encryptDb(password);
      setLocalStorage(localStorageObject);
      closeDialog("tempDialog");
      main();
    }
  } catch (err) {
    postError(err);
  }
}

async function addEntry(el) {
  try {
    let url = el.addEntryURL.value;
    let issuer;
    let name;
    let secret;
    let note;
    let algo = "SHA1";
    let period = 30;
    let digits = 6;
    let uuid = self.crypto.randomUUID();

    //build value object
    let entryTemplate = {
      type: "totp",
      uuid: uuid,
      name: name,
      issuer: issuer,
      note: note,
      favorite: false,
      icon: null,
      info: {
        secret: secret,
        algo: "SHA1",
        digits: digits,
        period: period
      },
      groups: []
    };

    let urlArray = new URL(url);
    //URL or manual
    if (url != "") {
      //let paramsString = "q=URLUtils.searchParams&topic=api";
      // otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&issuer=Example&algorithm=SHA1 &digits=6&period=30
      let searchParams = new URLSearchParams(urlArray.search);
      for (let [key, value] of searchParams) {
        let preVariable = entryTemplate;
        if (["secret", "algo", "digits", "period"].includes(key)) {
          preVariable = entryTemplate.info;
        }
        if (key == "algorithm") {
          key = "algo";
        }
        preVariable[key] = value;
      }
      let r = 9;
    } else {
      entryTemplate[issuer] = el.addEntryIssuer.value;
      entryTemplate[name] = el.addEntryName.value;
      entryTemplate[note] = el.addEntryNote.value;
      entryTemplate.info[secret] = el.addEntrySecret.value;
    }

    //create object if we need to
    if (!isValidlocalStorageObject()) {
      localStorageObject = {
        version: 1,
        header: {
          slots: [
            {
              type: 1,
              uuid: "2b7ef3b1-419e-479c-a094-98e52e5bb523",
              key: "",
              key_params: {
                nonce: "0",
                tag: ""
              },
              n: 32768,
              r: 8,
              p: 1,
              salt: "",
              repaired: true,
              is_backup: false
            }
          ],
          params: {
            nonce: "",
            tag: ""
          }
        },
        db: ""
      };
    }

    if (JSON.stringify(dbGlobal) == "{}") {
      dbGlobal = {
        version: 3,
        entries: [],
        groups: [],
        icons_optimized: true
      };
    }

    dbGlobal.entries.push(entryTemplate);
    await encryptDb(password);
    setLocalStorage(localStorageObject);
    main();
  } catch (err) {
    postError(err);
  }
}

async function changePassword(el) {
  try {
    let pw1 = el[0].value;
    let pw2 = el[1].value;
    if (!isValidlocalStorageObject()) {
      alert("There is no database yet.");
      return;
    }
    if (pw1 == pw2) {
      if (pw1 == "") {
        if (
          !confirm(
            "You have chosen a blank password. This means anyone can access your Authentication codes. This is UNWISE. Do you wish to continue?"
          )
        ) {
          return;
        }
      }
      password = pw1;
      closeDialog("changePasswordDialog");
      await encryptDb(password);
      setLocalStorage(localStorageObject);
      el[0].value = "";
      el[1].value = "";
      main();
    } else {
      window.alert("Passwords do not match");
    }
  } catch (err) {
    postError(err);
  }
}

function wipeDatabase() {
  if (
    confirm(
      "This will ERASE your current database. Please make sure you have a BACKUP to restore. Are you sure?"
    )
  ) {
    closeDialog("passwordDialog");
    setLocalStorage({});
    main();
  }
}

function tryPassword(pw) {
  closeDialog("passwordDialog");
  password = pw;
  main();
}

function openDialog(id) {
  let el = document.querySelector("#" + id);
  el.showModal();
}

function closeDialog(id) {
  let el = document.querySelector("#" + id);
  el.close();
}

function openMenu() {
  try {
    document.getElementById("main_page_component").style.display = "none";
    document.getElementById("menu_page_component").style.display = "block";
    document.getElementById("menu_icon").style.display = "none";
    document.getElementById("x_icon").style.display = "inline";
  } catch (err) {
    postError(err);
  }
}

function closeMenu() {
  try {
    document.getElementById("main_page_component").style.display = "block";
    document.getElementById("menu_page_component").style.display = "none";
    document.getElementById("menu_icon").style.display = "inline";
    document.getElementById("x_icon").style.display = "none";
  } catch (err) {
    postError(err);
  }
}

function getLocalStorageToTextbox() {
  try {
    errorArray = [];
    let jsonObject = getLocalStorage();
    let jsonString = JSON.stringify(jsonObject, null, "\t");
    document.getElementById("JSONSave").value = jsonString;
  } catch (err) {
    //postError(err);
    postError({
      name: "getAegisJsonFromTextbox",
      message: "Malformed JSON Data"
    });
  }
}

function setLocalStorageFromTextbox() {
  try {
    errorArray = [];
    let jsonString = document.getElementById("JSONSave").value;
    localStorageObject = JSON.parse(jsonString); //also set obj
    dbGlobal = {}; //wipe old data
    setLocalStorage(localStorageObject);
    document.getElementById("JSONSave").value = "";
    main(); //clear and rebuild
  } catch (err) {
    //postError(err);
    postError({
      name: "setAegisJsonFromTextbox",
      message: "Malformed JSON Data"
    });
  }
}

function exportAll() {
  try {
    if (
      !confirm(
        "This will export Aegis JSON encrypted database, and comments to clipboard. Are you sure?"
      )
    ) {
      return false;
    }
    localStorageObject = getLocalStorage();
    copytoclipboard2(JSON.stringify(localStorageObject, null, "\t"));
    alert("Your current Aegis JSON encrypted database is on the clipboard!");
  } catch (err) {
    postError(err);
  }
}

// ENCRYPTION DECRYPTION HMAC FUNCTIONS //

// for references see: https://github.com/vpelss/JsTOTPAuthenticator
async function hmac(
  keyHexString,
  stepHexString16Bytes,
  returnDigits,
  hashFunctionString
) {
  let totp;
  try {
    let blockSize = 64;
    let k, msg, tempUint8Array, hashed;

    //all our input key strings should only have hex characters [0 .. F]
    msg = Uint8Array.fromHex(stepHexString16Bytes);
    k = Uint8Array.fromHex(keyHexString); //only accepts hex string lengths of even values and convertys to bytes. byte = 2 x hex

    /*
    //HMAC: instructive
    //hmac_sha https://en.wikipedia.org/wiki/HMAC

    // create our Uint8Array key to the blockSize sized
    if (k.length > blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
      tempUint8Array.set(new Uint8Array(hashed));
      k = tempUint8Array;
    } // Keys longer than blockSize are shortened by hashing them
    // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
    if (k.length < blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      tempUint8Array.set(k);
      k = tempUint8Array;
    }
    // k should now be blockSize

    // create ipad and opad https://datatracker.ietf.org/doc/html/rfc2104#section-2
    let okey = new Uint8Array(k);
    okey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x5c;
    }); //key xor 0x5c
    let ikey = new Uint8Array(k);
    ikey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x36;
    }); //key xor 0x36

    // now do hash(o_key_pad concatenate hash(i_key_pad concatenate msg))

    tempUint8Array = concatenateUint8arrays([ikey, msg]); // i_key_pad + msg
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    tempUint8Array = new Uint8Array(hashed); // hash(i_key_pad concatenate msg)

    tempUint8Array = concatenateUint8arrays([okey, tempUint8Array]); //o_key_pad âˆ¥ hash(i_key_pad + msg)
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    hashed = new Uint8Array(hashed); // hash(o_key_pad concatenate hash(i_key_pad concatenate msg))
   */

    //HMAC: simpler, but not instructive
    let cryptoKey = await window.crypto.subtle.importKey(
      "raw",
      k,
      { name: "HMAC", hash: { name: "SHA-1" } },
      1,
      ["sign", "verify"]
    );
    hashed = await window.crypto.subtle.sign("HMAC", cryptoKey, msg);
    hashed = new Uint8Array(hashed);

    //https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
    let offset = hashed[hashed.length - 1] & 0xf; //last 4 bits of hashed

    //take 4 bytes at offset (minus the first bit) and use bits to create a decimal #
    let myBinary =
      ((hashed[offset] & 0x7f) << 24) | // not signed
      (hashed[offset + 1] << 16) |
      (hashed[offset + 2] << 8) |
      hashed[offset + 3];

    //take deciamal output of myBinary and reduce to returnDigits decimal characters
    // opt is the same as taking dp/myBinary taking the decimal and multiplying with dp
    let dp = 10 ** returnDigits;
    let otp = myBinary % dp;

    totp = otp.toString();
    while (totp.length < returnDigits) {
      // make sure it is returnDigits long. pad to the left
      totp = "0" + totp;
    }
    return totp;
  } catch (err) {
    postError(err);
  }
}

async function decryptDb(password) {
  try {
    let pw = password.normalize("NFKC");
    pw = TE.encode(password);

    // based on https://github.com/Sammy-T/avdu/blob/master/vault/decrypt.go
    // FindMasterKey uses the password to decrypt the master key
    // from the vault and returns the master key's bytes.

    // go salt, err := hex.DecodeString(slot.Salt)
    let saltString = localStorageObject.header.slots[0].salt;
    let salt = Uint8Array.fromHex(saltString);

    // Create a key using the slot values and provided password
    // go key, err = scrypt.Key([]byte(pwd), salt, slot.N, slot.R, slot.P, 32)
    let n = localStorageObject.header.slots[0].n;
    let r = localStorageObject.header.slots[0].r;
    let p = localStorageObject.header.slots[0].p;
    let dkLen = 32;

    // scrypt is password based key derivation
    //from https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js
    //https://github.com/ricmoo/scrypt-js?utm_source=cdnjs&utm_medium=cdnjs_link&utm_campaign=cdnjs_library#readme
    //let keyScrypt = scrypt.syncScrypt(pw, salt, n, r, p, dkLen); //syncronous
    let hashedPassword = await scrypt.scrypt(pw, salt, n, r, p, dkLen); //asyncronous

    //go nonce, err := hex.DecodeString(slot.KeyParams.Nonce)
    let nonceString = localStorageObject.header.slots[0].key_params.nonce;
    nonceString = nonceString.normalize("NFKC");
    let nonce = Uint8Array.fromHex(nonceString);

    // go	tag, err := hex.DecodeString(slot.KeyParams.Tag)
    let tagString = localStorageObject.header.slots[0].key_params.tag;
    let tag = Uint8Array.fromHex(tagString);

    // go slotKey, err := hex.DecodeString(slot.Key)
    let slotKeyString = localStorageObject.header.slots[0].key;
    let slotKey = Uint8Array.fromHex(slotKeyString);

    // go var keyData []byte = append(slotKey, tag...)
    let keyData = concatenateUint8arrays([slotKey, tag]);

    // Attempt to decrypt the master key
    // go	block, err := aes.NewCipher(key)
    // go aesgcm, err := cipher.NewGCM(block)
    //go masterKey, err = aesgcm.Open(nil, nonce, keyData, nil)
    let masterKey = await decrypt(nonce, hashedPassword, keyData);
    //let test =  await encrypt(nonce, keyScrypt, masterKey);

    // go nonce, err := hex.DecodeString(params.Nonce)
    nonceString = localStorageObject.header.params.nonce;
    nonceString = nonceString.normalize("NFKC");
    nonce = Uint8Array.fromHex(nonceString);

    // go tag, err := hex.DecodeString(params.Tag)
    tagString = localStorageObject.header.params.tag;
    tag = Uint8Array.fromHex(tagString);

    //go dbData, err := base64.StdEncoding.DecodeString(db)
    let db = localStorageObject.db;
    let dbData = Uint8Array.fromBase64(db);

    //go var database []byte = append(dbData, tag...)
    let database = concatenateUint8arrays([dbData, tag]);

    // go block, err := aes.NewCipher(masterKey)
    // go aesgcm, err := cipher.NewGCM(block)
    // go content, err := aesgcm.Open(nil, nonce, database, nil)
    let plaintext = await decrypt(nonce, masterKey, database);

    let unencrypted = TD.decode(plaintext);
    return unencrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return ""; //indicates fail
  }
}

async function decrypt(iv, key, ciphertext) {
  let decrypted;
  try {
    let block = await window.crypto.subtle.importKey(
      "raw",
      key,
      { name: "AES-GCM" },
      1,
      ["encrypt", "decrypt"]
    );
    decrypted = await window.crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      block,
      ciphertext
    );
    return decrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return;
  }
}

async function encryptDb(password) {
  try {
    openDialog("waitDialog");
    clearInterval(myInterval);

    // workimg backwards from decryptDB

    //create a 12 byte nonce
    let nonce = new Uint8Array(12);
    self.crypto.getRandomValues(nonce);
    //nonce = Uint8Array.fromHex(nonceString);
    let nonceString = nonce.toHex();
    //nonceString = localStorageObject.header.params.nonce;
    localStorageObject.header.params.nonce = nonceString;
    //create a 32 bit masterKey
    let masterKey = new Uint8Array(32);
    self.crypto.getRandomValues(masterKey);
    //convert dbGlobal to content Uint8Array
    let tempdb = JSON.stringify(dbGlobal, null, "\t"); //we don't need the formatting
    let plaintext = TE.encode(tempdb);
    //encrypt dbGlobal using nonce and masterKey
    let database = await encrypt(nonce, masterKey, plaintext);
    // database is an ArrayBuffer, not Uint8Array, so fix it
    database = new Uint8Array(database);

    //separate db and tag from encrypted database
    //db is 16 bytes larger, the last 16 byte tag is removed and stored as the tag
    //  let database = concatenateUint8arrays([dbData, tag]);
    let length = database.length;
    let dbData = database.slice(0, length - 16);
    //let dbData = Uint8Array.fromBase64(db);
    let db = dbData.toBase64();
    //let db = localStorageObject.db;
    localStorageObject.db = db;
    //tag = Uint8Array.fromHex(tagString);
    let tag = database.slice(length - 16, length);
    let tagString = tag.toHex();
    //tagString = localStorageObject.header.params.tag;
    localStorageObject.header.params.tag = tagString;

    let pw = password.normalize("NFKC");
    pw = TE.encode(password);
    //let saltString = localStorageObject.header.slots[0].salt;
    //let salt = Uint8Array.fromHex(saltString);
    let salt = new Uint8Array(32); //32 byte salt , 64 hex characters
    self.crypto.getRandomValues(salt);
    let saltString = salt.toHex();
    localStorageObject.header.slots[0].salt = saltString;

    let n = localStorageObject.header.slots[0].n;
    let r = localStorageObject.header.slots[0].r;
    let p = localStorageObject.header.slots[0].p;
    let dkLen = 32;
    let hashedPassword = await scrypt.scrypt(pw, salt, n, r, p, dkLen); //asyncronous

    //let nonceString = localStorageObject.header.slots[0].key_params.nonce;
    //nonceString = nonceString.normalize("NFKC");
    //let nonce = Uint8Array.fromHex(nonceString);
    self.crypto.getRandomValues(nonce); //new masterKey nonce
    nonceString = nonce.toHex();
    localStorageObject.header.slots[0].key_params.nonce = nonceString;
    //let masterKey = await decrypt(nonce, keyScrypt, keyData);
    let masterKeyEncrypted = await encrypt(nonce, hashedPassword, masterKey);
    //masterKeyEncrypted is 16 bytes bigger than masterKey so tag is that last 16 bytes and so masterKey the remaining first part
    //let masterKeyEncrypted = concatenateUint8arrays([slotKey, tag]);
    masterKeyEncrypted = new Uint8Array(masterKeyEncrypted);
    length = masterKeyEncrypted.length;
    let slotKey = masterKeyEncrypted.slice(0, length - 16);
    //let slotKey = Uint8Array.fromHex(slotKeyString);
    let slotKeyString = slotKey.toHex();
    //let slotKeyString = localStorageObject.header.slots[0].key;
    localStorageObject.header.slots[0].key = slotKeyString;
    tag = masterKeyEncrypted.slice(length - 16, length);
    //let tag = Uint8Array.fromHex(tagString);
    tagString = tag.toHex();
    //let tagString = localStorageObject.header.slots[0].key_params.tag;
    localStorageObject.header.slots[0].key_params.tag = tagString;

    //let encrypted = TD.decode(db);
    let encrypted = db;
    return encrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return;
  }
}

async function encrypt(iv, key, ciphertext) {
  let encrypted;
  try {
    let block = await window.crypto.subtle.importKey(
      "raw",
      key,
      { name: "AES-GCM" },
      1,
      ["encrypt", "decrypt"]
    );
    encrypted = await window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      block,
      ciphertext
    );
    return encrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return;
  }
}

// SUPPORT FUNCTIONS //

function leaingZeros(step) {
  // step needs to be 16 characters
  do {
    step = "0" + step;
  } while (step.length < 16);
  return step;
}

function isValidlocalStorageObject() {
  try {
    if (
      JSON.stringify(localStorageObject) == "{}" ||
      typeof localStorageObject.db == "undefined"
    ) {
      return false;
    } else {
      return true;
    }
  } catch (err) {
    postError(err);
  }
}

function buildEntriesDOM() {
  try {
    let entriesCount = 0;
    let entriesDiv = document.querySelector("#entriesDiv");
    entriesDiv.innerHTML = "";
    dbGlobal.entries.forEach(function (entry) {
      //replace template values
      // https://stackoverflow.com/questions/377961/efficient-javascript-string-replacement
      //https://stackoverflow.com/questions/68970312/how-do-i-resolve-a-javascript-template-literal-variable-within-a-string-within-a
      let modifiedTemplate = template("theTemplate", {
        entryId: "" + entriesCount
      });
      //add to #entriesDiv
      const toAppend = document.createElement("div");
      toAppend.innerHTML = modifiedTemplate;
      entriesDiv.append(toAppend);
      entriesCount += 1;
    });
  } catch (err) {
    postError(err);
  }
}

function setLocalStorage(localStorageObject) {
  //saves object as json string
  try {
    let jsonString = JSON.stringify(localStorageObject, null, "\t");
    localStorage[localStorageName] = jsonString;
  } catch (err) {
    //postError(err);
    postError({ name: "setLocalStorage", message: "Malformed JSON Data" });
  }
}

function getLocalStorage() {
  //returns object from json string
  //return empty object {} if undefined
  let jsonObject;
  try {
    if (typeof localStorage[localStorageName] == "undefined") {
      jsonObject = {};
    } else {
      let jsonString = localStorage[localStorageName];
      jsonObject = JSON.parse(jsonString);
    }
  } catch (err) {
    //postError(err);
    postError({ name: "getLocalStorage", message: "Malformed JSON Data" });
  } finally {
    return jsonObject;
  }
}

function supportsHtml5Storage() {
  try {
    return "localStorage" in window && window.localStorage !== null;
    //return false;
  } catch (err) {
    postError(err);
    //return false;
  }
}

function copytoclipboard2(text) {
  try {
    let textarea = document.createElement("TEXTAREA");
    document.body.appendChild(textarea);
    textarea.innerHTML = text;
    textarea.value = text;
    textarea.select();
    document.execCommand("copy", false, null);
    textarea.remove();
  } catch (err) {
    postError(err);
  }
}

// modified https://medium.com/@at.kishor.k/demystifying-base32-an-in-depth-guide-to-this-encoding-standard-697b9426fc25
function decodeBase32toHex(data) {
  try {
    const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    const HEX_ALPHABET = "0123456789ABCDEF";
    data = data.replace(/=/g, ""); //remove padding
    let binaryString = "";
    for (let i = 0; i < data.length; i++) {
      binaryString += BASE32_ALPHABET.indexOf(data[i])
        .toString(2)
        .padStart(5, "0");
    }
    let padding = binaryString.length % 8; //needs to be 8 as we want padding to account for bytes
    if (padding !== 0) {
      binaryString = binaryString.slice(0, -padding);
    }
    let decoded = "";
    for (let i = 0; i < binaryString.length; i += 4) {
      let decimalEquivilant = parseInt(binaryString.slice(i, i + 4), 2);
      decoded += HEX_ALPHABET[decimalEquivilant];
      //decoded += parseInt(binaryString.slice(i, i + 4), 2).toString(16).toUpperCase();
    }
    return decoded;
  } catch (err) {
    postError(err);
  }
}

// https://evanhahn.com/the-best-way-to-concatenate-uint8arrays/
function concatenateUint8arrays(uint8arrays) {
  try {
    // Determine the length of the result.
    const totalLength = uint8arrays.reduce(
      (total, uint8array) => total + uint8array.byteLength,
      0
    );
    // Allocate the result.
    const result = new Uint8Array(totalLength);
    // Copy each Uint8Array into the result.
    let offset = 0;
    uint8arrays.forEach((uint8array) => {
      result.set(uint8array, offset);
      offset += uint8array.byteLength;
    });
    return result;
  } catch (err) {
    postError(err);
  }
}

function template(templateid, data) {
  try {
    return document.getElementById(templateid).innerHTML.replace(
      ///%(\w*)%/g, // or /{(\w*)}/g for "{this} instead of %this%"
      /\${(\w*)}/g, // or  for "{this} instead of %this%"
      function (m, key) {
        return data.hasOwnProperty(key) ? data[key] : "";
      }
    );
  } catch (err) {
    postError(err);
  }
}

function postError(err) {
  errorArray.push({ Name: err.name, Message: err.message, Stack: err.stack });
  let errorString = JSON.stringify(errorArray, null, "\t");
  document.getElementById("error").innerHTML = "Errors:<br>" + errorString;
}
  </script>

  
</body>

</html>
