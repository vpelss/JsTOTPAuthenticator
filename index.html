
<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>totp</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  
  
  
  

  
  
  
</head>

<body>
  <!-- https://datatracker.ietf.org/doc/html/rfc6238 -->

<a href="https://en.wikipedia.org/wiki/Time-based_one-time_password" target="_blank">https://en.wikipedia.org/wiki/Time-based_one-time_password</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc6238" target="_blank">TOTP: Time-Based One-Time Password Algorithm</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc2104" target="_blank">HMAC Hashed Message Authentication Code</a>
<p></p>
<a href="https://en.wikipedia.org/wiki/HMAC" target="_blank">HMAC pseudo Code</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc4226#section-5.3" target="_blank">Generating an HOTP Value</a>

<p></p>

<input type="text" placeholder="secret" value="3132333435363738393031323334353637383930" id="seed" onchange="eachSecond();">

<p></p>
Step
<div id="step"></div>
Key
<div id="key"></div>
Code
<div id="answer"></div>
Countdown
<div id="countdown"></div>

<div id="error"></div>
  
    <script id="rendered-js" >
//the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

// I tried to follow https://datatracker.ietf.org/doc/html/rfc6238
//rfc is atrocious. It assumes you know the inner workings of java crypto/mac.
//So it effectively leaves out all the important code if you need to write it in a different language.
//it looks that crypto/mac does all the ipad and opad stuff
// https://en.wikipedia.org/wiki/HMAC was much more useful
async function hmac(
  keyHexString,
  stepHexString16Bytes,
  returnDigits,
  hashFunctionString
) {
  try {
    let blockSize = 64;
    let k, msg, tempUint8Array, hashed;

    //all our input key strings should only have hex characters
    msg = Uint8Array.fromHex(stepHexString16Bytes);
    k = Uint8Array.fromHex(keyHexString);

    //hmac_sha inline
    // create our Uint8Array key to the blockSize sized
    // Keys longer than blockSize are shortened by hashing them
    if (k.length > blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
      tempUint8Array.set(new Uint8Array(hashed));
      k = tempUint8Array;
    }
    // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
    if (k.length < blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      tempUint8Array.set(k);
      k = tempUint8Array;
    }
    // k should now be blockSize

    //o_key_pad ← block_sized_key xor [0x5c blockSize]   // Outer padded key
    //i_key_pad ← block_sized_key xor [0x36 blockSize]   // Inner padded key
    let okey = new Uint8Array(k);
    okey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x5c;
    }); //key xor 0x5c
    let ikey = new Uint8Array(k);
    ikey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x36;
    }); //key xor 0x36

    // now do hash(o_key_pad + hash(i_key_pad + msg))

    tempUint8Array = concatenateUint8arrays([ikey, msg]); // i_key_pad + msg
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    tempUint8Array = new Uint8Array(hashed); // hash(i_key_pad + msg)

    tempUint8Array = concatenateUint8arrays([okey, tempUint8Array]); //o_key_pad ∥ hash(i_key_pad + msg)
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    hashed = new Uint8Array(hashed); // hash(o_key_pad ∥ hash(i_key_pad ∥ message))

    //https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
    let offset = hashed[hashed.length - 1] & 0xf; //last 4 bits of hashed

    //take 4 bytes at offset (minus the first bit) and use bits to create a decimal #
    let myBinary =
      ((hashed[offset] & 0x7f) << 24) | // not signed
      (hashed[offset + 1] << 16) |
      (hashed[offset + 2] << 8) |
      hashed[offset + 3];

    // int otp = binary % DIGITS_POWER[codeDigits];
    //take deciamal output and reduce to returnDigits decimal characters
    // opt is the remander: so the decimal remander of myBinary / dp is .xxxx so a dp of 1000 will give us 4 digits
    let dp = 10 ** returnDigits;
    let otp = myBinary % dp;

    let result = otp.toString();
    while (result.length < returnDigits) {
      // make sure it is returnDigits long. pad to the left
      result = "0" + result;
    }

    document.getElementById("step").innerHTML = stepHexString16Bytes;
    document.getElementById("key").innerHTML = keyHexString;
    document.getElementById("answer").innerHTML = result;
  } catch (error) {
    document.getElementById("error").innerHTML = error;
  }
}

function decodeBase32toHex(data) {
  const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  const HEX_ALPHABET = "0123456789ABCDEF";
  data = data.replace(/=/g, "");
  let binaryString = "";
  for (let i = 0; i < data.length; i++) {
    binaryString += BASE32_ALPHABET.indexOf(data[i])
      .toString(2)
      .padStart(5, "0");
  }
  let padding = binaryString.length % 8;
  if (padding !== 0) binaryString = binaryString.slice(0, -padding);
  let decoded = "";
  let decoded1 = "";
  for (let i = 0; i < binaryString.length; i += 4) {
    ii = parseInt(binaryString.slice(i, i + 4), 2);
    iii = HEX_ALPHABET[ii];
    decoded += HEX_ALPHABET[parseInt(binaryString.slice(i, i + 4), 2)];
    //decoded += parseInt(binaryString.slice(i, i + 4), 2).toString(16).toUpperCase();
  }
  return decoded;
}

//https://evanhahn.com/the-best-way-to-concatenate-uint8arrays/
function concatenateUint8arrays(uint8arrays) {
  // Determine the length of the result.
  const totalLength = uint8arrays.reduce(
    (total, uint8array) => total + uint8array.byteLength,
    0
  );
  // Allocate the result.
  const result = new Uint8Array(totalLength);
  // Copy each Uint8Array into the result.
  let offset = 0;
  uint8arrays.forEach((uint8array) => {
    result.set(uint8array, offset);
    offset += uint8array.byteLength;
  });
  return result;
}

function eachSecond() {
  let unixTime = Date.now() / 1000; //in seconds
  let stepNow = unixTime / 30;
  let stepInt = Math.floor(stepNow);
  let timeLeft = Math.floor(30 - 30 * (stepNow - stepInt));
  //step MUST be in string HEX
  let step = stepInt.toString(16);
  document.getElementById("countdown").innerHTML = timeLeft;
  do {
    step = "0" + step;
  } while (step.length < 16);
  // step needs to be 16 characters
  let seedBase32 = document.getElementById("seed").value;
  //base32Str to HexStr
  // https://mojoauth.com/binary-encoding-decoding/base32-with-javascript-in-browser#encoding-data-to-base32
  seed = decodeBase32toHex(seedBase32);
  const TE = new TextEncoder();
  const TD = new TextDecoder();

  let returnDigits = 6;
  let crypto = "sha1";

  try {
    hmac(seed, step, returnDigits, crypto);
  } catch (error) {
    document.getElementById("error").innerHTML = error;
  }
}

// MAIN //

//first test
//step MUST be in string HEX
//toString(16).toUpperCase()
step = Math.floor(1111111109 / 30)
  .toString(16)
  .toUpperCase();
do {
  step = "0" + step;
} while (step.length < 16);

let seed;
seed = document.getElementById("seed").value;
let returnDigits = 8;
let crypto = "sha1";

hmac(seed, step, returnDigits, crypto);

document.getElementById("seed").value = "MYTESTQ";
let myInterval = setInterval(eachSecond, 1000);
  </script>

  
</body>

</html>
