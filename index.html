<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>JsTOTPAuthenticator</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="manifest" href="./manifest.json"> 
  
  <link rel='stylesheet' href='https://cdn.simplecss.org/simple.css'>
  
<style>
body {
  margin: 2px;
}

#header {
  position: sticky;
  top: 0;
  background-color: white;
  width: 100%;
}

.codeClass {
  font-size: 2rem;
}

#theBar {
  border: solid;
  border-width: 1px;
  height: 3px;
  background-color: red;
  transition: width 2s linear;
}

#theBar2{
  transition: value 2s linear;
  height: 3px;
}

.myTemplate {
  display: table;
  width: 100%;
  border: solid;
  border-width: 1px;
  margin: 5px;
  padding: 5px;
}

.leftTemplate {
  display: table-cell;
}

.rightTemplate {
  display: table-cell;
  text-align: right;
}

#error {
  white-space: pre-wrap;
  display: block;
  }

.secret { /*fix / block password managers forcing fields to fill*/
    -webkit-text-security: disc;
}
</style>

  
  
  
</head>

<body>
  <div id="header">
  <center>
    <span id="menu_icon">
      <a onclick="openMenu();" class="button">&#x2261;</a>
    </span>
    <span id="x_icon" hidden>
      <a onclick="closeMenu()" class="button">X</a>
    </span>
    &nbsp;&nbsp;&nbsp;
    <span>
      JsTOTPAuthenticator
    </span>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <span id="add_icon">
      <a onclick="openDialog('addEntryDialog')" class="button">+</a>
    </span>
  </center>
  <div>
      <progress id="theBar" value="0" max="100"></progress>
  </div>
</div>

<template id="theTemplate">
  <div id="${entryId}" class="myTemplate">
    <div class="leftTemplate">
      <div id="${entryName}">Loading Database</div>
      <div id="${entryCode}" class="codeClass">Loading Database</div>
    </div>
    <div class="rightTemplate">
      <a href="#" id="${entryCopyLink}" class="button"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#ffffff">
          <path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z" />
        </svg>
      </a>
    </div>
  </div>
</template>

<div_main_page id="main_page_component">
  <div id="entriesDiv">
    Waiting to load encrypted Aegis database
  </div>
</div_main_page>

<div_menu_page id="menu_page_component" hidden>

  <form>
    <center>
      <div>
        <input type="button" value="Get Aegis JSON encrypted database" onclick="getLocalStorageToTextbox();">
      </div>

      <div>
        <input type="button" value="Save Aegis JSON encrypted database" onclick="if(confirm('This will overwrite your current Aegis JSON encrypted database. Are you sure?')){setLocalStorageFromTextbox();}">
      </div>

      <div>
        <input type="button" value="Export your Aegis JSON encrypted database to Clipboard" onclick="if(confirm('This will export Aegis JSON encrypted database, and comments to clipboard. Are you sure?')){ ExportAll(); alert('Your current Aegis JSON encrypted database is on the clipboard!');}">
      </div>

      <div>
        <textarea id="JSONSave" rows="3" cols="50" placeholder="Import/Export/Backup Aegis JSON encrypted database. Save the text generated in a safe location." title="You can import/export your current  Aegis JSON encrypted database (which is saved localy). This is helful to move it to another computer or use it as a backup." class="u-full-width">
</textarea>
      </div>
    </center>
  </form>

  <center>
    <div>
      <a href="#" id="changePassword" class="button" onclick="openDialog('changePasswordDialog')">Change Password</a>
    </div>
    
    <div>
      <a href="#" id="install" class="button">Install as PWA</a>
    </div>

    <div>
      Links below will open in your default browser.
    </div>

    <div>
      <a href="https://raw.githubusercontent.com/vpelss/JsTOTPAuthenticator/refs/heads/main/README.md" class="button u-full-width" target="_blank">Help/Read Me</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator" target="_blank" class="button u-full-width">Github</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator/blob/main/LICENSE" target="_blank" class="button">Licence</a>
    </div>

  </center>

</div_menu_page>

<dialog id="passwordDialog">
  <p>Unencrypt Aegis Database</p>
  <form method="dialog" onsubmit="tryPassword(document.querySelector('#password').value);document.querySelector('#password').value='';">
    <center>
      <div>
        <input type="text" id="password" placeholder="Password" class="secret" autocomplete="off">
      </div>
      <div>
        <input type="submit" value="Submit">
      </div>
      <div>
        Or if you forgot your pw or database is corrupt.
      </div>
      <div>
        <input type="button" value="Erase Database" onclick="wipeDatabase()">
      </div>
    </center>
  </form>
</dialog>

<dialog id="changePasswordDialog">
  <p>Add An Entry</p>
  <form method="dialog" onsubmit="changePassword(this)">
    <center>
      <div></div>
      <div>
        <input type="text" id="newPassword1" placeholder="New Password" autocomplete="off" class="secret">
      </div>
      <div>
        <input type="text" id="newPassword2" placeholder="New Password again" autocomplete="off" class="secret">
      </div>
      <div>
        <input type="submit" value="Submit">
      </div>
      <p></p>
      <div>
        <input type="button" value="Cancel" onclick="closeDialog('changePasswordDialog')">
      </div>
    </center>
  </form>
</dialog>

<dialog id="addEntryDialog">
  <p>Add An Entry</p>
  <form method="dialog" onsubmit="addEntry(this)">
    <center>
      <div>
        <input type="text" id="entryName" placeholder="Name" autocomplete="off">
      </div>
      <div>
        <input type="text" id="entrySecret" placeholder="Secret" autocomplete="off">
      </div>
      <div>
        <input type="submit" value="Submit">
      </div>
      <p></p>
      <div>
        <input type="button" value="Cancel" onclick="closeDialog('addEntryDialog')">
      </div>
    </center>
  </form>
</dialog>

<p></p>

<div id="error"></div>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js'></script>
    <script id="rendered-js" >
"use strict";

let password = ""; //it can be "", but we insist on a password when
let myInterval;
let localStorageName = "JsTOTPAuthenticator";
let localStorageObject = {};
let dbGlobal; //entries, groups, ect

// DO WE NEED THIS...
//let dbGlobal.entries = []; //just entries

let errorArray = [];
let oldStepInt = 0;
let entriesDiv = document.querySelector("#entriesDiv");
const TE = new TextEncoder();
const TD = new TextDecoder();

// the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

// no global db??

// + on add an entry, store and encrypt and rebuild dom

//always encrypt. password can be "" but if on save or export, ensure that a passwod is set!!! Warning etc

//TO DO:
//build aegis json db
//add entry
//input url
//qr code?
//show secret
//add issuer and notes
//copied alert message

// START MAIN LOOP //

main();

async function main() {
  try {
    //fresh start
    clearInterval(myInterval);
    closeMenu();
    errorArray = [];
    document.querySelector("#error").innerHTML = "";
    entriesDiv.innerHTML = "Loading database and attempting decrypt"; //this may be an imp0rt(dont fix this) situation
    document.getElementById("JSONSave").value = "";

    //does browser support local storage? yes continue : no stop
    if (!supportsHtml5Storage()) {
      throw {
        name: "Error",
        message: "HTML5 Storage is not supported in this browser"
      };
    }

    //is there  local storage and is it JSON? yes continue : no stop
    localStorageObject = getLocalStorage(); //load database
    if (JSON.stringify(localStorageObject) == "{}") {
      //no error is required
      //throw { name: "No local database", message: "No local database" };
      entriesDiv.innerHTML =
        "No database found. Import an Aegis database with &#x2261; or start adding entries with the +";
      return;
    }

    //test to see if json is valid Aegis format. I am only weak testing for localStorageObject.db
    if (typeof localStorageObject.db == "undefined") {
      //no error is required
      //throw { name: "main", message: "Not a vaiid Aegis JSON format" };
      entriesDiv.innerHTML =
        "No database found. Import an Aegis database with &#x2261; or start adding entries with the +";
      return;
    }

    //assume pw is "" and try to decrypt
    //if it fails bring up passwordDialog it will either:
    //1. wipe local storage and run main()
    //2. set password and run main()
    //unencrypt Aegis JSON DB : AES CGM
    let dbJSON = await unencryptDb(password);
    if (dbJSON == "") {
      //pw failed so open passwordDialog
      openDialog("passwordDialog");
      //throw {name: "main",message: "Password is incorrect or maybe JSON Database is corrupt"};
      return;
    }

    dbGlobal = JSON.parse(dbJSON);
    dbGlobal.entries = dbGlobal.entries;
    //let test = await encryptDb(password);

    // dbGlobal.entries = localStorageObject.entries;
    dbJSON = ""; //data no longer needed
    buildEntriesDOM(); //this has to be here as we need to wait for the promise

    myInterval = setInterval(eachSecond, 1000); //start counter
  } catch (err) {
    postError(err);
  }
}

async function eachSecond() {
  try {
    if (dbGlobal.entries.length == 0) {
      return "No entries yet";
    }
    let unixTime = Date.now() / 1000; //in seconds
    let stepNow = unixTime / 30;
    let stepInt = Math.floor(stepNow); //this changes when == to stepNow. so bar should be at 100%
    let step = stepInt.toString(16); //step MUST be in string HEX
    //show countdown
    // let percentDone = Math.floor( 100 * (stepNow - stepInt + (1/30)) ) ; //need to add one tick 1/30 to progress bar so we can reach 100%
    let percentDone = Math.floor(100 * (stepNow - stepInt));
    let barWidth = 100 - percentDone;
    if (stepInt != oldStepInt) {
      //percentDone will never coincide with our setInterval. so make barr 100 on change
      barWidth = 100;
      oldStepInt = stepInt;
    }
    var progress = document.querySelector("#theBar");
    progress.value = barWidth;

    // step needs to be 16 characters
    do {
      step = "0" + step;
    } while (step.length < 16);

    // calculate and output code for each entry and place on template
    let entriesCount = 0;
    for (let entry of dbGlobal.entries) {
      let name = entry.name;
      let algo = entry.info.algo;
      let digits = entry.info.digits;
      let period = entry.info.period;
      let seedBase32 = entry.info.secret;
      let seed = decodeBase32toHex(seedBase32.toUpperCase()); //base32Str to HexStr
      let totp;
      try {
        totp = await hmac(seed, step, digits, algo);
      } catch (err) {
        postError(err);
      }

      document.getElementById("entryName" + entriesCount).innerHTML = name;
      document.getElementById("entryCode" + entriesCount).innerHTML = totp;
      document.getElementById(
        "entryCopyLink" + entriesCount
      ).onclick = function () {
        copytoclipboard2(totp);
      };
      entriesCount += 1;
    }
  } catch (err) {
    postError(err);
  }
}

// BUTTON FUNCTIONS //

async function addEntry(el) {
  try {
    let entryName = el[0].value;
    let entrySecret = el[1].value;

    let uuid = self.crypto.randomUUID();

    let template = {
      type: "totp",
      uuid: uuid,
      name: entryName,
      issuer: "",
      note: "",
      favorite: false,
      icon: null,
      info: {
        secret: entrySecret,
        algo: "SHA1",
        digits: 6,
        period: 30
      },
      groups: []
    };

    dbGlobal.entries.push(template);
    encryptDb();
    setLocalStorage(localStorageObject);
    main();
  } catch (err) {
    postError(err);
  }
}

async function changePassword(el) {
  try {
    let pw1 = el[0].value;
    let pw2 = el[1].value;
    if (pw1 == pw2) {
      password = pw1;
      closeDialog("changePasswordDialog");
      await encryptDb(password);
      setLocalStorage(localStorageObject);
      el[0].value = "";
      el[1].value = "";
      main();
    } else {
      window.alert("Passwords do not match");
    }
  } catch (err) {
    postError(err);
  }
}

function wipeDatabase() {
  if (
    confirm(
      "This will ERASE your current database. Please make sure you have a BACKUP to restore. Are you sure?"
    )
  ) {
    closeDialog("passwordDialog");
    setLocalStorage({});
    main();
  }
}

function tryPassword(pw) {
  closeDialog("passwordDialog");
  password = pw;
  main();
}

function openDialog(id) {
  let el = document.querySelector("#" + id);
  el.showModal();
}

function closeDialog(id) {
  let el = document.querySelector("#" + id);
  el.close();
}

function openMenu() {
  try {
    document.getElementById("main_page_component").style.display = "none";
    document.getElementById("menu_page_component").style.display = "block";
    document.getElementById("menu_icon").style.display = "none";
    document.getElementById("x_icon").style.display = "inline";
  } catch (err) {
    postError(err);
  }
}

function closeMenu() {
  try {
    document.getElementById("main_page_component").style.display = "block";
    document.getElementById("menu_page_component").style.display = "none";
    document.getElementById("menu_icon").style.display = "inline";
    document.getElementById("x_icon").style.display = "none";
  } catch (err) {
    postError(err);
  }
}

function getLocalStorageToTextbox() {
  try {
    errorArray = [];
    let jsonObject = getLocalStorage();
    let jsonString = JSON.stringify(jsonObject, null, "\t");
    document.getElementById("JSONSave").value = jsonString;
  } catch (err) {
    //postError(err);
    postError({
      name: "getAegisJsonFromTextbox",
      message: "Malformed JSON Data"
    });
  }
}

function setLocalStorageFromTextbox() {
  try {
    errorArray = [];
    let jsonString = document.getElementById("JSONSave").value;
    localStorageObject = JSON.parse(jsonString); //also set obj
    setLocalStorage(localStorageObject);
    document.getElementById("JSONSave").value = "";
    main(); //clear and rebuild
  } catch (err) {
    //postError(err);
    postError({
      name: "setAegisJsonFromTextbox",
      message: "Malformed JSON Data"
    });
  }
}

function exportAll() {
  try {
    localStorageObject = GetLocalStorage();
    copytoclipboard2(JSON.stringify(localStorageObject, null, "\t"));
  } catch (err) {
    postError(err);
  }
}

// ENCRYPTION DECRYPTION HMAC FUNCTIONS //

// for references see: https://github.com/vpelss/JsTOTPAuthenticator
async function hmac(
  keyHexString,
  stepHexString16Bytes,
  returnDigits,
  hashFunctionString
) {
  let totp;
  try {
    let blockSize = 64;
    let k, msg, tempUint8Array, hashed;

    //all our input key strings should only have hex characters [0 .. F]
    msg = Uint8Array.fromHex(stepHexString16Bytes);
    k = Uint8Array.fromHex(keyHexString); //only accepts hex string lengths of even values and convertys to bytes. byte = 2 x hex

    /*
    //HMAC: instructive
    //hmac_sha https://en.wikipedia.org/wiki/HMAC

    // create our Uint8Array key to the blockSize sized
    if (k.length > blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
      tempUint8Array.set(new Uint8Array(hashed));
      k = tempUint8Array;
    } // Keys longer than blockSize are shortened by hashing them
    // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
    if (k.length < blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      tempUint8Array.set(k);
      k = tempUint8Array;
    }
    // k should now be blockSize

    // create ipad and opad https://datatracker.ietf.org/doc/html/rfc2104#section-2
    let okey = new Uint8Array(k);
    okey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x5c;
    }); //key xor 0x5c
    let ikey = new Uint8Array(k);
    ikey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x36;
    }); //key xor 0x36

    // now do hash(o_key_pad concatenate hash(i_key_pad concatenate msg))

    tempUint8Array = concatenateUint8arrays([ikey, msg]); // i_key_pad + msg
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    tempUint8Array = new Uint8Array(hashed); // hash(i_key_pad concatenate msg)

    tempUint8Array = concatenateUint8arrays([okey, tempUint8Array]); //o_key_pad âˆ¥ hash(i_key_pad + msg)
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    hashed = new Uint8Array(hashed); // hash(o_key_pad concatenate hash(i_key_pad concatenate msg))
   */

    //HMAC: simpler, but not instructive
    let cryptoKey = await window.crypto.subtle.importKey(
      "raw",
      k,
      { name: "HMAC", hash: { name: "SHA-1" } },
      1,
      ["sign", "verify"]
    );
    hashed = await window.crypto.subtle.sign("HMAC", cryptoKey, msg);
    hashed = new Uint8Array(hashed);

    //https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
    let offset = hashed[hashed.length - 1] & 0xf; //last 4 bits of hashed

    //take 4 bytes at offset (minus the first bit) and use bits to create a decimal #
    let myBinary =
      ((hashed[offset] & 0x7f) << 24) | // not signed
      (hashed[offset + 1] << 16) |
      (hashed[offset + 2] << 8) |
      hashed[offset + 3];

    //take deciamal output of myBinary and reduce to returnDigits decimal characters
    // opt is the same as taking dp/myBinary taking the decimal and multiplying with dp
    let dp = 10 ** returnDigits;
    let otp = myBinary % dp;

    totp = otp.toString();
    while (totp.length < returnDigits) {
      // make sure it is returnDigits long. pad to the left
      totp = "0" + totp;
    }
    return totp;
  } catch (err) {
    postError(err);
  }
}

async function unencryptDb(password) {
  try {
    let pw = password.normalize("NFKC");
    pw = TE.encode(password);

    // based on https://github.com/Sammy-T/avdu/blob/master/vault/decrypt.go
    // FindMasterKey uses the password to decrypt the master key
    // from the vault and returns the master key's bytes.

    // go salt, err := hex.DecodeString(slot.Salt)
    let saltString = localStorageObject.header.slots[0].salt;
    let salt = Uint8Array.fromHex(saltString);

    // Create a key using the slot values and provided password
    // go key, err = scrypt.Key([]byte(pwd), salt, slot.N, slot.R, slot.P, 32)
    let n = localStorageObject.header.slots[0].n;
    let r = localStorageObject.header.slots[0].r;
    let p = localStorageObject.header.slots[0].p;
    let dkLen = 32;

    // scrypt is password based key derivation
    //from https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js
    //https://github.com/ricmoo/scrypt-js?utm_source=cdnjs&utm_medium=cdnjs_link&utm_campaign=cdnjs_library#readme
    //let keyScrypt = scrypt.syncScrypt(pw, salt, n, r, p, dkLen); //syncronous
    let keyScrypt = await scrypt.scrypt(pw, salt, n, r, p, dkLen); //asyncronous

    //go nonce, err := hex.DecodeString(slot.KeyParams.Nonce)
    let nonceString = localStorageObject.header.slots[0].key_params.nonce;
    nonceString = nonceString.normalize("NFKC");
    let nonce = Uint8Array.fromHex(nonceString);

    // go	tag, err := hex.DecodeString(slot.KeyParams.Tag)
    let tagString = localStorageObject.header.slots[0].key_params.tag;
    let tag = Uint8Array.fromHex(tagString);

    // go slotKey, err := hex.DecodeString(slot.Key)
    let slotKeyString = localStorageObject.header.slots[0].key;
    let slotKey = Uint8Array.fromHex(slotKeyString);

    // go var keyData []byte = append(slotKey, tag...)
    let keyData = concatenateUint8arrays([slotKey, tag]);

    // Attempt to decrypt the master key
    // go	block, err := aes.NewCipher(key)
    // go aesgcm, err := cipher.NewGCM(block)
    //go masterKey, err = aesgcm.Open(nil, nonce, keyData, nil)
    let masterKey = await decrypt(nonce, keyScrypt, keyData);
    //let test =  await encrypt(nonce, keyScrypt, masterKey);

    // go nonce, err := hex.DecodeString(params.Nonce)
    nonceString = localStorageObject.header.params.nonce;
    nonceString = nonceString.normalize("NFKC");
    nonce = Uint8Array.fromHex(nonceString);

    // go tag, err := hex.DecodeString(params.Tag)
    tagString = localStorageObject.header.params.tag;
    tag = Uint8Array.fromHex(tagString);

    //go dbData, err := base64.StdEncoding.DecodeString(db)
    let db = localStorageObject.db;
    let dbData = Uint8Array.fromBase64(db);

    //go var database []byte = append(dbData, tag...)
    let database = concatenateUint8arrays([dbData, tag]);

    // go block, err := aes.NewCipher(masterKey)
    // go aesgcm, err := cipher.NewGCM(block)
    // go content, err := aesgcm.Open(nil, nonce, database, nil)
    let content = await decrypt(nonce, masterKey, database);

    let unencrypted = TD.decode(content);
    return unencrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return ""; //indicates fail
  }
}

async function decrypt(iv, key, ciphertext) {
  let decrypted;
  try {
    let block = await window.crypto.subtle.importKey(
      "raw",
      key,
      { name: "AES-GCM" },
      1,
      ["encrypt", "decrypt"]
    );
    decrypted = await window.crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      block,
      ciphertext
    );
    return decrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return;
  }
}

async function encryptDb(password) {
  try {
    // workimg backwards from decryptDB
    let pw = password.normalize("NFKC");
    pw = TE.encode(password);

    //create a 12 byte nonce
    let nonce = new Uint8Array(12);
    self.crypto.getRandomValues(nonce);
    //create a 32 bit masterKey
    let masterKey = new Uint8Array(32);
    self.crypto.getRandomValues(masterKey);
    //create a 16 bit tag
    //let tag = new Uint8Array(16);
    //self.crypto.getRandomValues(tag);
    //convert localStorageObject to content Uint8Array
    let tempdb = JSON.stringify(dbGlobal, null, "\t"); //we don't need the formatting
    let content = TE.encode(tempdb);
    let database = await encrypt(nonce, masterKey, content);
    // database is an ArrayBuffer, not Uint8Array, so fix it
    database = new Uint8Array(database);
    //db is 16 bytes larger, the last 16 byte tag is removed and stored as the tag
    //  let database = concatenateUint8arrays([dbData, tag]);
    let length = database.length;
    let dbData = database.slice(0, length - 16);
    //let dbData = Uint8Array.fromBase64(db);
    let db = dbData.toBase64();
    //let db = localStorageObject.db;
    localStorageObject.db = db;
    //tag = Uint8Array.fromHex(tagString);
    let tag = database.slice(length - 16, length);
    let tagString = tag.toHex();
    //tagString = localStorageObject.header.params.tag;
    localStorageObject.header.params.tag = tagString;
    //nonce = Uint8Array.fromHex(nonceString);
    let nonceString = nonce.toHex();
    //nonceString = localStorageObject.header.params.nonce;
    localStorageObject.header.params.nonce = nonceString;

    //let saltString = localStorageObject.header.slots[0].salt;
    //let salt = Uint8Array.fromHex(saltString);
    let salt = new Uint8Array(32); //32 byte salt , 64 hex characters
    self.crypto.getRandomValues(salt);
    let saltString = salt.toHex();
    localStorageObject.header.slots[0].salt = saltString;

    let n = localStorageObject.header.slots[0].n;
    let r = localStorageObject.header.slots[0].r;
    let p = localStorageObject.header.slots[0].p;
    let dkLen = 32;
    let keyScrypt = await scrypt.scrypt(pw, salt, n, r, p, dkLen); //asyncronous

    //let nonceString = localStorageObject.header.slots[0].key_params.nonce;
    //nonceString = nonceString.normalize("NFKC");
    //let nonce = Uint8Array.fromHex(nonceString);
    self.crypto.getRandomValues(nonce); //new masterKey nonce
    nonceString = nonce.toHex();
    localStorageObject.header.slots[0].key_params.nonce = nonceString;
    //let masterKey = await decrypt(nonce, keyScrypt, keyData);
    let keyData = await encrypt(nonce, keyScrypt, masterKey);
    //keyDaya is 16 bytes bigger than masterKey so tag is that last 16 bytes and so masterKey the remaining first part
    //let keyData = concatenateUint8arrays([slotKey, tag]);
    keyData = new Uint8Array(keyData);
    length = keyData.length;
    let slotKey = keyData.slice(0, length - 16);
    //let slotKey = Uint8Array.fromHex(slotKeyString);
    let slotKeyString = slotKey.toHex();
    //let slotKeyString = localStorageObject.header.slots[0].key;
    localStorageObject.header.slots[0].key = slotKeyString;
    tag = keyData.slice(length - 16, length);
    //let tag = Uint8Array.fromHex(tagString);
    tagString = tag.toHex();
    //let tagString = localStorageObject.header.slots[0].key_params.tag;
    localStorageObject.header.slots[0].key_params.tag = tagString;

    //let encrypted = TD.decode(db);
    let encrypted = db;
    return encrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return;
  }
}

async function encrypt(iv, key, ciphertext) {
  let encrypted;
  try {
    let block = await window.crypto.subtle.importKey(
      "raw",
      key,
      { name: "AES-GCM" },
      1,
      ["encrypt", "decrypt"]
    );
    encrypted = await window.crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      block,
      ciphertext
    );
    return encrypted;
  } catch (err) {
    //dont bother outer code will log error
    //postError(err);
    return;
  }
}

// SUPPORT FUNCTIONS //

function buildEntriesDOM() {
  try {
    let entriesCount = 0;
    let entriesDiv = document.querySelector("#entriesDiv");
    entriesDiv.innerHTML = "";
    dbGlobal.entries.forEach(function (entry) {
      //replace template values
      // https://stackoverflow.com/questions/377961/efficient-javascript-string-replacement
      //https://stackoverflow.com/questions/68970312/how-do-i-resolve-a-javascript-template-literal-variable-within-a-string-within-a
      let modifiedTemplate = template("theTemplate", {
        entryId: "" + entriesCount,
        entryName: "entryName" + entriesCount,
        entryCode: "entryCode" + entriesCount,
        entryCopyLink: "entryCopyLink" + entriesCount
      });
      //add to #entriesDiv
      const toAppend = document.createElement("div");
      toAppend.innerHTML = modifiedTemplate;
      entriesDiv.append(toAppend);
      entriesCount += 1;
    });
  } catch (err) {
    postError(err);
  }
}

function setLocalStorage(localStorageObject) {
  //saves object
  try {
    let jsonString = JSON.stringify(localStorageObject, null, "\t");
    localStorage[localStorageName] = jsonString;
  } catch (err) {
    //postError(err);
    postError({ name: "setLocalStorage", message: "Malformed JSON Data" });
  }
}

function getLocalStorage() {
  //returns object
  //return {} if undefined
  let json;
  try {
    if (typeof localStorage[localStorageName] != "undefined") {
      let jsonString = localStorage[localStorageName];
      json = JSON.parse(jsonString);
    }
  } catch (err) {
    //postError(err);
    postError({ name: "getLocalStorage", message: "Malformed JSON Data" });
  } finally {
    return json;
  }
}

function supportsHtml5Storage() {
  try {
    return "localStorage" in window && window.localStorage !== null;
    //return false;
  } catch (err) {
    postError(err);
    //return false;
  }
}

function copytoclipboard2(text) {
  try {
    let textarea = document.createElement("TEXTAREA");
    document.body.appendChild(textarea);
    textarea.innerHTML = text;
    textarea.value = text;
    textarea.select();
    document.execCommand("copy", false, null);
    textarea.remove();
  } catch (err) {
    postError(err);
  }
}

// modified https://medium.com/@at.kishor.k/demystifying-base32-an-in-depth-guide-to-this-encoding-standard-697b9426fc25
function decodeBase32toHex(data) {
  try {
    const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    const HEX_ALPHABET = "0123456789ABCDEF";
    data = data.replace(/=/g, ""); //remove padding
    let binaryString = "";
    for (let i = 0; i < data.length; i++) {
      binaryString += BASE32_ALPHABET.indexOf(data[i])
        .toString(2)
        .padStart(5, "0");
    }
    let padding = binaryString.length % 8; //needs to be 8 as we want padding to account for bytes
    if (padding !== 0) {
      binaryString = binaryString.slice(0, -padding);
    }
    let decoded = "";
    for (let i = 0; i < binaryString.length; i += 4) {
      let decimalEquivilant = parseInt(binaryString.slice(i, i + 4), 2);
      decoded += HEX_ALPHABET[decimalEquivilant];
      //decoded += parseInt(binaryString.slice(i, i + 4), 2).toString(16).toUpperCase();
    }
    return decoded;
  } catch (err) {
    postError(err);
  }
}

// https://evanhahn.com/the-best-way-to-concatenate-uint8arrays/
function concatenateUint8arrays(uint8arrays) {
  try {
    // Determine the length of the result.
    const totalLength = uint8arrays.reduce(
      (total, uint8array) => total + uint8array.byteLength,
      0
    );
    // Allocate the result.
    const result = new Uint8Array(totalLength);
    // Copy each Uint8Array into the result.
    let offset = 0;
    uint8arrays.forEach((uint8array) => {
      result.set(uint8array, offset);
      offset += uint8array.byteLength;
    });
    return result;
  } catch (err) {
    postError(err);
  }
}

function template(templateid, data) {
  try {
    return document.getElementById(templateid).innerHTML.replace(
      ///%(\w*)%/g, // or /{(\w*)}/g for "{this} instead of %this%"
      /\${(\w*)}/g, // or  for "{this} instead of %this%"
      function (m, key) {
        return data.hasOwnProperty(key) ? data[key] : "";
      }
    );
  } catch (err) {
    postError(err);
  }
}

function postError(err) {
  errorArray.push({ Name: err.name, Message: err.message, Stack: err.stack });
  let errorString = JSON.stringify(errorArray, null, "\t");
  document.getElementById("error").innerHTML = "Errors:<br>" + errorString;
}

let example = {
  type: "totp",
  uuid: "8ebf3a2c-687b-4c88-9fe1-3a8a6ca3d59e",
  name: "8xc",
  issuer: "",
  note: "",
  favorite: false,
  icon: null,
  info: {
    secret: "CCCCCCCC",
    algo: "SHA1",
    digits: 6,
    period: 30
  },
  groups: []
};
  </script>

  
</body>

</html>
